import fs from 'node:fs';
import { createHash } from 'node:crypto';

let previous;
try {
  previous = await import('./index.js');
} catch (e) {
  if (e.code !== 'ERR_MODULE_NOT_FOUND') {
    throw e;
  }
}

(async function main(retries = 5) {
  if (retries <= 0) {
    throw new Error('Failed to fetch media types');
  }

  try {
    const init = {
      redirect: 'follow',
    };
    if (previous?.lastModified) {
      init.headers = new Headers({
        'if-modified-since': previous.lastModified.toUTCString(),
      });
    }
    const response = await fetch(
      'https://www.iana.org/assignments/media-types/media-types.xml',
      init,
    );
    const { ok, status, statusText } = response;
    if (!ok) {
      const cause = status === 304 ? 'no-change' : undefined;
      throw new Error(`HTTP ${status} ${statusText}`, { cause });
    }

    const textData = await response.text();
    const dom =
      typeof DOMParser === 'undefined'
        ? new (await import('jsdom')).JSDOM(textData).window.document
        : new DOMParser().parseFromString(textData, 'application/xml');

    const mediaTypes = Array.from(
      new Set(
        (function* () {
          for (const registry of dom.querySelectorAll(
            '#media-types registry',
          )) {
            const title = registry.querySelector('title')?.textContent;
            if (!title) {
              continue;
            }
            for (const record of registry.getElementsByTagName('record')) {
              yield record.querySelector('file[type=template]')?.textContent ??
                `${title}/${record.querySelector('name').textContent}`;
            }
          }
        })(),
      ),
    ).sort();

    const index = JSON.stringify(mediaTypes, null, 2) + '\n';
    const hash = createHash('sha256').update(index).digest('hex');
    const lastModified = response.headers.get('last-modified') || null;
    const updated = new Date().toUTCString();
    if (hash === previous?.hash) {
      throw new Error('No relevant changes', { cause: 'no-change' });
    }

    fs.writeFileSync('index.json', index);
    fs.writeFileSync(
      'index.js',
      `\
// @generated by build.js
export const lastModified = new Date(${JSON.stringify(lastModified)});
export const updated = new Date(${JSON.stringify(updated)});
export const hash =
  ${JSON.stringify(hash)};

export default ${index};
`,
    );
  } catch (error) {
    if (error.cause === 'no-change') {
      throw error;
    }
    retries -= 1;
    console.error(error);
    console.warn(`There are ${retries} retries left...\n`);
    await new Promise((r) => setTimeout(r, 12_000));
    main(retries);
  }
})();
